#!/usr/bin/env lua
-- htmlfier: Renders a textual Fountain AST (Haskell Show-style, generated by the `fountain-parser`) to HTML
-- Usage: lua htmlfier <script.ast>
-- Output: script.html (same base name)

-- Utility to print error messages to stderr and terminate the script
local function die(msg)
  io.stderr:write(msg .. '\n')
  os.exit(1)
end

-- Ensure an input filename was provided as a command line argument
if not arg[1] then
  die('Usage: lua htmlfier <script.ast>')
end

-- Determine input and output file paths based on the provided argument
local infile = arg[1]
local basename = infile:gsub('%.%w+$', '') -- strip the last extension, if any
local outfile = basename .. '.html'

-- Attempt to read the entire contents of the input file into memory
local fh = io.open(infile, 'r')
if not fh then die('Cannot open the input file: ' .. infile) end
local src = fh:read('*a')
fh:close()

-- ------------- --
-- Brief Helpers --
-- ------------- --

-- Removes leading and trailing whitespace from a string
local function trim(s) return (s:gsub('^%s+', ''):gsub('%s+$', '')) end

-- Replaces reserved HTML characters with their respective character entities
local function escape_html(s)
  return (s
    :gsub('&', '&amp;')
    :gsub('<', '&lt;')
    :gsub('>', '&gt;')
  )
end

-- Normalises strings for use as CSS classes (lowercase, alphanumeric, dash-separated)
local function slugify_class(s)
  s = s
    :lower() -- Lowercase
    :gsub('[^%w%s%-_]+', '') -- Strip non-letters
    :gsub('%s+', '-') -- Map spaces to dashes
  return s
end

-- ------------------------ --
--     RichText Mapping     --
-- (Very lightweight parser --
--  Using simple patterns)  --
-- ------------------------ --

-- Processes individual blocks of formatted text (italics, bold, etc.)
local function render_richtext_block(block)
  -- `block`: A raw textual slice, e.g.: `[TextNode "Hello", EmItalic [TextNode "world"]]`
  -- Strategy: Transform known inline tags into spans; leave everything else as plain text
  -- First, extract all the nested `textnode "...`` elements, preserving order
  local out = {}

  -- Helper to find specific emphasis tags and convert them to HTML span elements
  -- Replacing emphasis wrappers with these placeholders affords re-wrapping
  -- EmItalic [TextNode "folan"] -> <span class = "em-italic">folan</span>
  -- EmBold [TextNode "folan"] -> <span class = "em-bold">folan</span>
  -- EmBoldItalics [TextNode "folan"] -> <span class = "em-bold-italic">folan</span>
  -- EmUnderline [TextNode "folan"] -> <span class = "em-underline">folan</span>
  -- EmEscaped [TextNode "folan"] -> folan
  -- EmNoteInline [TextNode "folan"] -> <span class = "em-note-inline">folan</span>
  local function wrap(tag, cls)
    block = block:gsub(tag .. '%s*%[(.-)%]', function(inner)
      local txt = inner:match('TextNode%s+"(.-)"') or inner
      txt = escape_html(txt)

      if cls == 'plain' then
        return txt
      else
        return '<span class="' .. cls .. '">' .. txt .. '</span>'
      end
    end)
  end

  -- Apply transformations for all supported Fountain emphasis types
  wrap('EmBoldItalics', 'em-bold-italic')
  wrap('EmItalic', 'em-italic')
  wrap('EmBold', 'em-bold')
  wrap('EmUnderline', 'em-underline')
  wrap('EmNoteInline', 'em-note-inline')
  wrap('EmEscaped', 'plain')

  -- Any remaining `TextNode "..."` elements become plain text
  block:gsub('TextNode%s+"(.-)"', function(txt)
    table.insert(out, escape_html(txt))
  end)

  -- If the emphasis wrappers produced spans, they are already in a block.
  -- Includ ethem as well.
  -- Capture any existing HTML spans produced above:
  block:gsub('(<span.->.-</span>)', function(span)
    table.insert(out, span)
  end)

  if #out == 0 then
    return ''
  end

  -- Join by the empty string.
  -- The upstream controls the spacing in the TextNode content.
  return table.concat(out)
end

-- Processes a collection of richtext lines (used for Action or Lyrics)
local function render_richtext_values(values_block)
  -- `values_block`: `[[TextNode "..."], [TextNode "...", EmItalic [TextNode "..."]], ...]`
  -- Render each inner [...] group on its own line
  local html_lines = {}
  values_block:gsub('%[(.-)%]', function(group)
    local line_html = render_richtext_block(group)
    
    if line_html and line_html ~= '' then
      table.insert(html_lines, line_html)
    end
  end)

  return table.concat(html_lines, '\n')
end

-- --------------------- --
-- Title Page Extraction --
-- --------------------- --

-- Storage for metadata found in the TitlePage section of the AST
local title_fields = {}

do
  -- Identify the TitlePage block within the source string
  local tp_block = src:match('TitlePage%s*%{(.-)%}') -- Grab the content between { ... }

  if tp_block then
    -- Iterate TitleField blocks and extract keys and values
    for tf in tp_block:gmatch('TitleField%s*%{(.-)%}') do
      local key = tf:match('tfKey%s*=%s*"([^"]+)"') or 'Field'
      local values = tf:match('tfValues%s*=%s*(%b[])') or '[]'
      local html_value = render_richtext_values(values)

      -- Store key-value pairs with a slugified class for styling
      table.insert(title_fields, {
        key = key,
        class = slugify_class(key),
        value = html_value
      })
    end
  end
end

-- ------------------------------ --
-- Screenplay Elements Extraction --
-- ------------------------------ --

-- Storage for the main body elements of the screenplay
local elements = {}

local function push(elem) table.insert(elements, elem) end

-- Overall strategy: Iterate by lines; handle complex items by pattern matching the whole line
for line in src:gmatch('[^\n]+') do
  line = trim(line)

  -- Scene Heading: Includes the location text and optional scene number
  if line:match('^FESceneHeading%s*%(') then
    local text = line:match('shText%s*=%s*"([^"]-)"') or ''
    local num = line:match('shNumber%s*=%s*Just%s*"([^"]-)"')
    local html = '<p class="scene-heading">' .. escape_html(text)

    if num and #num > 0 then
      html = html .. ' <span class="scene-number">(' .. escape_html(num) .. ')</span>'
    end

    html = html .. '</p>'
    push({ kind = 'scene-heading', html = html })

  -- Action: Represents descriptive prose in the script
  elseif line:match('^FEAction%s*%(') then
    local lines_block = line:match('actionLines%s*=%s*(%b[])') or '[]'
    -- `actionLines` is a list of richtext line: [[TextNode "..."], [...], ...]
    local content = render_richtext_values(lines_block)
    local html = '<p class="action">' .. content .. '</p>'
    push({ kind = 'action', html = html })

  -- Character: A standalone character cue
  -- (Rare in the output, unless followed by a dialogue)
  elseif line:match('^FECharacter%s*%(') then
    local name = line:match('charName%s*=%s*"([^"]-)"') or ''
    local ext = line:match('charExtension%s*=%s*Just%s*"([^"]-)"')
    local html = '<p class="character">' .. escape_html(name)

    if ext and #ext > 0 then
      html = html .. ' <span class="extension">' .. escape_html(ext) .. '</span>'
    end

    html = html .. '</p>'
    push({ kind = 'character', html = html })
  
  -- Dialogue: Includes the character name and the spoken lines (including parentheticals)
  elseif line:match('^FEDialogue%s*%(') then
    local speaker = line:match('charName%s*=%s*"([^"]-)"') or ''
    local ext = line:match('charExtension%s*=%s*Just%s*"([^"]-)"')
    local lines_block = line:match('dlgLines%s*=%s*(%b[])') or '[]'

    local character_html = '<p class="character">' .. escape_html(speaker)
    if ext and #ext > 0 then
      character_html = character_html .. ' <span class="extension">' .. escape_html(ext) .. '</span>'
    end
    character_html = character_html .. '</p>'

    -- dlgLines contains `DialogueText [...]` and possibly also `Parenthetical [...]`;
    -- => Render sequentially
    local dialogue_chunks = {}
    lines_block:gsub('DialogueText%s*(%b[])', function(rt)
      local txt = render_richtext_block(rt:sub(2, -2))

      if txt ~= '' then
        table.insert(dialogue_chunks, '<p class="dialogue">' .. txt .. '</p>')
      end
    end)
    
    lines_block:gsub('Parenthetical%s*(%b[])', function(rt)
      local txt = render_richtext_block(rt:sub(2, -2))

      if txt ~= '' then
        table.insert(dialogue_chunks, '<p class="parenthetical">(' .. txt .. ')</p>')
      end
    end)

    local html = character_html .. table.concat(dialogue_chunks, '')
    push({ kind = 'dialogue', html = html })

  -- Dual Dialogue: Side-by-side dialogue blocks
  elseif line:match('^FEDualDialogue%s*%(') then
    -- Extract left, right blocks
    local left_block = line:match('ddLeft%s*=%s*DialogueBlock%s*%{(.-)%}%s*,%s*ddRight') or ''
    local right_block = line:match('ddRight%s*=%s*DialogueBlock%s*%{(.-)%}%s*%)') or ''

    -- Inner helper to render a single dialogue block (Character + Lines)
    local function render_dialogue_block(block)
      local speaker = block:match('charName%s*=%s*"([^"]-)"') or ''
      local ext = block:match('charExtension%s*=%s*Just%s*"([^"]-)"')
      local lines_block = block:match('dlgLines%s*=%s*(%b[])') or '[]'

      local character_html = '<p class="character">' .. escape_html(speaker)
      if ext and #ext > 0 then
        character_html = character_html .. ' <span class="extension">' .. escape_html(ext) .. '</span>'
      end
      character_html = character_html .. '</p>'

      -- dlgLines contains `DialogueText [...]` and possibly also `Parenthetical [...]`;
      -- => Render sequentially
      local chunks = {}
      lines_block:gsub('DialogueText%s*(%b[])', function(rt)
        local txt = render_richtext_block(rt:sub(2, -2))

        if txt ~= '' then
          table.insert(chunks, '<p class="dialogue">' .. txt .. '</p>')
        end
      end)
      
      lines_block:gsub('Parenthetical%s*(%b[])', function(rt)
        local txt = render_richtext_block(rt:sub(2, -2))

        if txt ~= '' then
          table.insert(chunks, '<p class="parenthetical">(' .. txt .. ')</p>')
        end
      end)

      return character_html .. table.concat(chunks, '')
    end

    local left_html = render_dialogue_block(left_block)
    local right_html = render_dialogue_block(right_block)

    -- Wrap the two blocks in a container for side-by-side styling
    local html = '<div class="dual-dialogue">' ..
                    '<div class="dual-left">' .. left_html .. '</div>' ..
                    '<div class="dual-right">' .. right_html .. '</div>' ..
                  '</div>'
    
    push({ kind = 'dual-dialogue', html = html })

  -- Transition: e.g., CUT TO:
  elseif line:match('^FETransition%s*%(') then
    local txt = line:match('trText%s*=%s*"([^"]-)"') or ''
    local html = '<p class="transition">' .. escape_html(txt) .. '</p>'
    push({ kind = 'transition', html = html })

  -- Centred Text: Often used for emphasis or title cards
  elseif line:match('^FECentred%s*%(') then
    local lines_block = line:match('centredLines%s*=%s*(%b[])') or '[]'
    local content = render_richtext_values(lines_block)
    local html = '<p class="centred">' .. content .. '</p>'
    push({ kind = 'centred', html = html })

  -- Lyric: Usually indicated by a musical note in screenplay software
  elseif line:match('^FELyric%s*%(') then
    local lines_block = line:match('lyricLines%s*=%s*(%b[])') or '[]'
    local content = render_richtext_values(lines_block)
    local html = '<p class="lyric">' .. content .. '</p>'
    push({ kind = 'lyric', html = html })

  -- Notes, sections, synopsis, boneyard
  -- (Hidden by CSS, but we still emit these)
  elseif line:match('^FENote%s*%(') then
    local txt = line:match('noteText%s*=%s*"([^"]-)"') or ''
    push({ kind = 'note', html = '<p class="note">' .. escape_html(txt) .. '</p>' })
  elseif line:match('^FESection%s*%(') then
    local txt = line:match('sectionTitle%s*=%s*"([^"]-)"') or ''
    push({ kind = 'section', html = '<p class="section">' .. escape_html(txt) .. '</p>' })
  elseif line:match('^FESynopsis%s*%(') then
    local txt = line:match('synopsisText%s*=%s*"([^"]-)"') or ''
    push({ kind = 'synopsis', html = '<p class="synopsis">' .. escape_html(txt) .. '</p>' })
  elseif line:match('^FEBoneyard%s*%(') then
    local txt = line:match('boneyardText%s*=%s*"([^"]-)"') or ''
    push({ kind = 'boneyard', html = '<p class="boneyard">' .. escape_html(txt) .. '</p>' })

  -- Page breaks and blank lines: Structural elements
  elseif line:match('^FEPageBreak%s*%(') then
    push({ kind = 'page-break', html = '<hr class="page-break">' })
  elseif line:match('^FEBlankLine%s*%(') then
    push({ kind = 'blank-line', html = '<div class="blank-line"></div>' })
  end
end

-- ------------------- --
-- Build HTML Document --
-- ------------------- --

-- Logic to determine what the <title> tag in the HTML head should be
local title_for_head = (function()
  for _, f in ipairs(title_fields) do
    if f.key:lower() == 'title' then
      -- First line of the title: Value for <title>
      local first = f.value:match('([^\n]+)') or f.value
      return (first:gsub('<.->', '')) -- Strip the spans
    end
  end

  -- Try the first scene heading as a fallback if no Title field exists
  for _, e in ipairs(elements) do
    if e.kind == 'scene-heading' then
      return (e.html:gsub('<.->', '')) -- Crude strip tags
    end
  end

  return 'Screenplay'
end)()

-- Converts stored TitlePage fields into an HTML container
local function render_title_page()
  if #title_fields == 0 then return '' end

  local out = {}
  
  table.insert(out, '<div class="title-page">')

  for _, f in ipairs(title_fields) do
    table.insert(out, '<div class="tp-field ' .. f.class .. '">')
    table.insert(out, '<div class="tp-key">' .. escape_html(f.key) .. '</div>')
    table.insert(out, '<div class="tp-value">' .. f.value .. '</div>')
    table.insert(out, '</div>')
  end

  table.insert(out, '</div>')
  return table.concat(out, '\n')
end

-- Aggregates all screenplay body elements into a single HTML container
local function render_screenplay()
  local out = {}
  table.insert(out, '<div class="screenplay">')

  for _, e in ipairs(elements) do
    table.insert(out, e.html)
  end

  table.insert(out, '</div>')
  return table.concat(out, '\n')
end

-- Construct the final HTML string with boilerplate and stylesheet links
local html = table.concat({
  '<!DOCTYPE html>',
  '<html lang="en">',
  '<head>',
  '<meta charset="utf-8">',
  '<meta name="viewport" content="width=device-width, initial-scale=1">',
  '<title>' .. escape_html(title_for_head) .. '</title>',
  '<link rel="stylesheet" href="screenplay.css">',
  '</head>',
  '<body>',
  render_title_page(),
  render_screenplay(),
  '</body>',
  '</html>'
}, '\n')

-- Write the generated HTML string to the output file
local oh = io.open(outfile, 'w')
if not oh then die('Cannot open the output file: ' .. outfile) end
oh:write(html)
oh:close()

print('Wrote: ' .. outfile)
